library(shiny)
library(wpp2019)
library(tidyverse)
library(bslib)

# data prep ----
#................................................
# DATA PREP:
# select a few countries, grab relevant WPP
# data, and calculate the projected populations
# assuming an immediate change to replacement-
# level TFR in 2020
#................................................

sel_codes = c('Brazil'                   =  76,
              'China'                    = 156,
              'Egypt'                    = 818,
              'Ethiopia'                 = 231,
              'Guatemala'                = 320,
              'India'                    = 356,
              'Iraq'                     = 368,
              'Japan'                    = 392,
              'Republic of Korea'        = 410,
              'Nigeria'                  = 566,
              'Norway'                   = 578,
              'Serbia'                   = 688,
              'South Africa'             = 710,
              'Turkey'                   = 792,
              'United States of America' = 840)
                
                
sel_names = names(sel_codes)

# make a tibble with one row per selected country
# and list-columns as follows
# country_code, name, TFR, NRR,
#    Nx (21x1), Lx (21x1), Fx (21x1), 
#    Sx (21 x 1, survival elements of Leslie matrix)
#    Kx (21 x 1, first row of Leslie matrix)

# prepare a small data frame with age distributions
# and Leslie multipliers, for the selected countries

data(popF, tfr, percentASFR, mxF)

tfr_info = tfr %>% 
            filter(country_code %in% sel_codes) %>% 
            select(country_code, name, tfr=`2015-2020`)

pop_info = popF %>% 
             filter(country_code %in% sel_codes) %>% 
             select(country_code, name, pop=`2020`) %>% 
             group_by(country_code, name) %>% 
             summarize( Nx = list(pop)) 
    
Fx_info = percentASFR %>% 
            filter(country_code %in% sel_codes) %>% 
            select(country_code, name,age, pct=`2015-2020`) %>% 
            left_join(tfr_info) %>% 
            mutate( asfr = tfr * pct/500) %>% 
            select(country_code, name, asfr) %>% 
            group_by(country_code, name) %>% 
            summarize( Fx = list(c(0,0,0,asfr,rep(0,11)))) 

# function to approx Lx for (0,5,10,...,100) from
# lx for (0,*1*,5,10,...,100)

calc_Lx = function(lx) {
    n   = length(lx)-1
    tmp = rep(NA, n)

    tmp[1]       = 1 * (lx[1] + lx[2])/2 + 
                   4 * (lx[2] + lx[3])/2          #  1L0 + 4L1
    tmp[2:(n-1)] = 5 * (lx[3:n] + lx[4:(n+1)])/2  #  5Lx
    tmp[n]       = 5 * (lx[n+1] + 0)/2            #  5L95
    return(tmp)
}

Lx_info = mxF %>% 
           filter(country_code %in% sel_codes) %>% 
           select(country_code, name,age, mx=`2015-2020`) %>% 
           group_by(country_code, name) %>% 
           mutate(hx = diff(c(age,Inf)) * mx,
                  Hx = cumsum(c(0,head(hx,-1))),
                  lx = exp(-Hx)) %>% 
           summarize( Lx  = list(calc_Lx(lx)))  

mx100_info = mxF %>% 
            filter(country_code %in% sel_codes,
                   age==100) %>% 
            select(country_code, name,m100=`2015-2020`) %>% 
            mutate(S100 = exp(-5*m100))


# join the (list-column) datasets by country

D = tfr_info %>% 
            inner_join(pop_info) %>% 
            inner_join(Fx_info) %>% 
            inner_join(Lx_info) %>% 
            inner_join(mx100_info) %>% 
            as_tibble()

# calculate NRR and the Leslie Matrix elements

calc_NRR = function(Lx_values,Fx_values) {
     LL  = unlist(Lx_values)
     FF  = unlist(Fx_values)
    # assumes that 4-10th age groups are 15-19... 45-49
    0.4886 * sum(LL*FF)
}

calc_Sx = function(Lx_values, S100) {
    LL  = unlist(Lx_values)
    ix  = 1:20
    tmp = LL[ix+1]/LL[ix]   #S0...S95 
    return(c(tmp, S100))
}

calc_Kx = function(Lx_values, Fx_values) {
  LL = unlist(Lx_values)
  FF = unlist(Fx_values)
  # start with all zeroes
  tmp = 0*LL
  # age groups 10-14 [3rd] through 45-49 [10th] element will have non-zero values
  ix = 3:10
  tmp[ix] = 0.4886 * LL[1]/2 * (FF[ix] + FF[ix+1] * LL[ix+1]/LL[ix])
  return(tmp)
}

D$NRR = map2_dbl(D$Lx, D$Fx, calc_NRR)
D$Sx  = map2(D$Lx, D$S100, calc_Sx)
D$Kx  = map2(D$Lx, D$Fx, calc_Kx)

# calculate projection for population by age 0-4,5-9,...,95-99,100+
# in 2020, 2025, ..., 2170

calc_projection = function(Nx, Sx, Kx, NRR) {
  SS = unlist(Sx)      # survival multipliers
  KK = unlist(Kx)/NRR  # kid multipliers AT REPLACEMENT LEVEL
  NN = unlist(Nx)      # 2020 pop
  
  Proj = matrix(NA, 21, 31, 
                dimnames=list(seq(0,100,5), seq(2020,2170,5)))
  
  Proj[,'2020'] = NN
  
  for (y in seq(2025,2170,5)) {
    thisy = paste(y)
    lasty = paste(y-5)
    
    Proj[ 1, thisy] = sum( KK * Proj[,lasty])
    Proj[-1, thisy] = SS[1:20] * Proj[1:20,lasty]
    Proj[21, thisy] = Proj[21,thisy] + SS[21] * Proj[21,lasty]
  }
  
  return(Proj)
}

D$projection = pmap(select(D, Nx,Sx,Kx,NRR), calc_projection)


# shiny app ----
# .....................................................
#  set up inputs and outputs for Shiny app
# .....................................................


# Define UI for application that draws a histogram
ui <- fluidPage(
  
  theme = bslib::bs_theme(
    bootswatch = "pulse", 
    base_font = font_google('Sarabun') 
  ),

    title = 'Population Momentum',
  
    # Application title
    titlePanel(HTML("Population Momentum<br/>(if Replacement-Level Fertility starts in 2020)")),

    # Sidebar with a slider input for number of bins 
    sidebarLayout(
        sidebarPanel(
            selectInput(inputId  = 'country', 
                        label    = 'Select a Country',
                        choices  = sel_names,
                        selected = sel_names[1],
                        width    = '80%'),
            
            sliderInput(inputId = 'year',
                        label = HTML('Select a year<br/>(Click Play to animate)'),
                        value = 2020,
                        min   = 2020,
                        max   = 2170,
                        sep   = '',
                        step  = 5,
                        round = FALSE,
                        width='80%',
                        animate = animationOptions(
                          interval = 800,
                          loop=TRUE,
#                          playButton = HTML('<br/><b><small>Project Forward at Replacement TFR</small></b>'),
                          playButton = NULL,
                          pauseButton = NULL
                        ))
            
        ),

        # Show a plot of the generated distribution
        mainPanel(
           plotOutput("PopPlot", width='80%'),
           plotOutput("TotalPlot", width='80%')
        )
    )
)

# Define server logic required to draw a histogram
server <- function(input, output) {

    dark_purple  = "#4B0082" #indigo
    light_purple = '#8A2BE2' #blueviolet
    
    hue20 = '#E0B0FF'  # for population 20+
    hue40 = '#DA70D6'  # for population 40+
    hue60 = '#673147'  # for population 60+
  
    output$PopPlot <- renderPlot({
        # generate bins based on input$bins from ui.R
        age    <- seq(0,100,5)

        # fpop is the matrix of projectsions: 
        # 21 ages 0,5,...100 by 
        # 21 years 2020, 2025, ..., 2120

        tmp = D %>% 
                filter(name == input$country)
        
        fpop = tmp$projection[[1]] 
        
        yr = as.character(input$year)
        
        this_title = paste(toupper(input$country),
                           'Female Population',yr,
                           '\nTFR in 2020=',sprintf("%.2f",tmp$tfr), 
                           '\nNRR in 2020=',sprintf("%.2f",tmp$NRR))
        
        pop_start = sum( fpop[,'2020'])
        pop_now   = sum( fpop[, yr])
        
        this_info = paste0('2020 Population = ',
                          sprintf("%.0f", pop_start),
                          '\n',yr,' Population = ',
                          sprintf("%.0f", pop_now),
                          '\n',
                          sprintf("%.0f",100*pop_now/pop_start),
                          '% of original population')

        # draw the histogram with the specified number of bins
        ggplot() +
             aes(x=age, y=fpop[,yr]) +
             geom_point(color=dark_purple, size=2) +
             geom_line(color=dark_purple, size=0.5) +
             geom_line(aes(x=age, y=fpop[,'2020']),
                       color='grey',size=4,alpha=.40) +
             labs( title= this_title,
                   x = 'Five-Year Age Group',
                   y = "Population (1000s)",
                   caption = "Source: UN World Population Prospects, 2019") +
             scale_y_continuous(limits=range(0,fpop)) +
             scale_x_continuous(breaks=seq(0,100,10)) +
             theme_bw() +
             geom_text( aes(x=31, y=0.30*fpop['0','2020'],
                        label=this_info), size=4) +
             geom_text( aes(x=85, y = .80*max(fpop), 
                            label=yr), color=dark_purple, size=10)
    })
    
    output$TotalPlot <- renderPlot({
      # generate bins based on input$bins from ui.R
      age    <- seq(0,100,5)
      
      # fpop is the matrix of projectsions: 
      # 21 ages 0,5,...100 by 
      # 21 years 2020, 2025, ... CURRENT YEAR
      
      tmp = D %>% 
        filter(name == input$country)
      
      fpop = tmp$projection[[1]] 
      
      ix20 = paste(seq(20,100,5))   # index ages for 20+
      ix40 = paste(seq(40,100,5))   # index ages for 40+
      ix60 = paste(seq(60,100,5))   # index ages for 60+
      
      if (input$year > 2020) {
         total_pop = fpop[, paste(seq(2020,input$year,5))] %>% 
                       colSums()
         pop20 = fpop[ix20, paste(seq(2020,input$year,5))] %>% 
                       colSums()
         pop40 = fpop[ix40, paste(seq(2020,input$year,5))] %>% 
                       colSums()
         pop60 = fpop[ix60, paste(seq(2020,input$year,5))] %>% 
                       colSums()
      } else {
        total_pop = sum(fpop[,'2020'])
        pop20 = sum(fpop[ix20,'2020'])
        pop40 = sum(fpop[ix40,'2020'])
        pop60 = sum(fpop[ix60,'2020'])
      }
      
      yr = as.character(input$year)
      
      this_title = paste(toupper(input$country),
                         'Total Female Population')

      

      xx   = input$year
      yy   = sum(fpop[,yr])
      yy20 = tail(pop20,1)
      yy40 = tail(pop40,1)
      yy60 = tail(pop60,1)
      
      yrs = seq(2020,input$year,5)
      ggplot() +
        aes(x=yrs, y=total_pop) +
        geom_point(size=2.5,color=light_purple) +
        geom_point(aes(x=xx, y=yy),size=5, color=light_purple, shape=1) +
        geom_text(aes(x=xx, y=yy, label=paste(yr,'Total')),color=light_purple, 
                  hjust=0.25,
                  nudge_x = 5, nudge_y = -.05*sum(fpop[,'2020'])) +
        geom_line(color=light_purple) +
        
        geom_line(aes(x=yrs,y=pop20),color=hue20) +
        geom_line(aes(x=yrs,y=pop40),color=hue40) +
        geom_line(aes(x=yrs,y=pop60),color=hue60) +
        
        geom_point(aes(x=yrs,y=pop20),color=hue20) +
        geom_point(aes(x=yrs,y=pop40),color=hue40) +
        geom_point(aes(x=yrs,y=pop60),color=hue60) +
        

        geom_text(aes(x=xx, y=yy20, label='20+'), color=hue20,                   
                  hjust=0,nudge_x =2, nudge_y = -.02* tail(pop60,1)) +
        geom_text(aes(x=xx, y=yy40, label='40+'), color=hue40,                   
                  hjust=0,nudge_x =2, nudge_y = -.02* tail(pop60,1)) +
        geom_text(aes(x=xx, y=yy60, label='60+'), color=hue60,                   
                  hjust=0,nudge_x =2, nudge_y = -.02* tail(pop60,1)) +
        
        labs( title= this_title,
              x = 'Year',
              y = "Population (1000s)",
              caption = "Source: UN World Population Prospects, 2019") +
        scale_y_continuous(limits=range(0,colSums(fpop))) +
        scale_x_continuous(breaks=seq(2020,2170,10),
                           limits=c(2020,2170)) +
        theme_bw() 

    })
}

# Run the application 
shinyApp(ui = ui, server = server)
