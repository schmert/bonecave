} else {
theta = c(theta, curr_theta)
}
}
plot(ts(theta))
windows(record=TRUE)
mu  = c(1,0)
tau = c(1,4)
sigma = tau^(-1/2)
logf1 = function(theta) { dnorm(theta, mu[1], sigma[1], log=TRUE)}
logf2 = function(theta) { dnorm(theta, mu[2], sigma[2], log=TRUE)}
nsim = 10000
curr_theta = 0
curr_logf  = logf1(curr_theta) + logf2(curr_theta)
theta = NULL
for (i in 1:nsim) {
prop_theta = curr_theta + runif(1, -.25, +.25)
prop_logf  = logf1(prop_theta) + logf2(prop_theta)
logu       = log(runif(1))
accept = (logu < prop_logf - curr_logf)
if (accept) {
theta = c(theta, prop_theta)
curr_theta = prop_theta
curr_logf  = prop_logf
} else {
theta = c(theta, curr_theta)
}
}
plot(ts(theta))
plot(density(theta))
curve( dnorm(x,0.2, 1/sqrt(5)), add=TRUE, col='red')
mu_pred = weighted.mean(mu, w=tau)
mu_pred
mu_pred = weighted.mean(mu, w=tau)
sd_pred = 1/sqrt(sum(tau))
sd_pred
mu  = c(1,0)
tau = c(1,4)
sigma = tau^(-1/2)
mu_pred = weighted.mean(mu, w=tau)
sd_pred = 1/sqrt(sum(tau))
logf1 = function(theta) { dnorm(theta, mu[1], sigma[1], log=TRUE)}
logf2 = function(theta) { dnorm(theta, mu[2], sigma[2], log=TRUE)}
nsim = 100000
curr_theta = 0
curr_logf  = logf1(curr_theta) + logf2(curr_theta)
theta = NULL
for (i in 1:nsim) {
prop_theta = curr_theta + runif(1, -.25, +.25)
prop_logf  = logf1(prop_theta) + logf2(prop_theta)
logu       = log(runif(1))
accept = (logu < prop_logf - curr_logf)
if (accept) {
theta = c(theta, prop_theta)
curr_theta = prop_theta
curr_logf  = prop_logf
} else {
theta = c(theta, curr_theta)
}
}
plot(ts(theta))
plot(density(theta))
curve( dnorm(x,mu_pred, sd_pred), add=TRUE, col='red')
windows(record=TRUE)
mu  = c(1,0)
tau = c(1,4)
sigma = tau^(-1/2)
mu_pred = weighted.mean(mu, w=tau)
sd_pred = 1/sqrt(sum(tau))
logf1 = function(theta) { dnorm(theta, mu[1], sigma[1], log=TRUE)}
logf2 = function(theta) { dnorm(theta, mu[2], sigma[2], log=TRUE)}
nsim = 100000
curr_theta = 0
curr_logf  = logf1(curr_theta) + logf2(curr_theta)
theta = NULL
for (i in 1:nsim) {
prop_theta = curr_theta + runif(1, -.25, +.25)
prop_logf  = logf1(prop_theta) + logf2(prop_theta)
logu       = log(runif(1))
accept = (logu < prop_logf - curr_logf)
if (accept) {
theta = c(theta, prop_theta)
curr_theta = prop_theta
curr_logf  = prop_logf
} else {
theta = c(theta, curr_theta)
}
}
plot(ts(theta))
plot(density(theta))
curve( dnorm(x,mu_pred, sd_pred), add=TRUE, col='blue')
mu  = c(10,0)
tau = c(1,2)
sigma = tau^(-1/2)
mu_pred = weighted.mean(mu, w=tau)
sd_pred = 1/sqrt(sum(tau))
logf1 = function(theta) { dnorm(theta, mu[1], sigma[1], log=TRUE)}
logf2 = function(theta) { dnorm(theta, mu[2], sigma[2], log=TRUE)}
nsim = 100000
curr_theta = 0
curr_logf  = logf1(curr_theta) + logf2(curr_theta)
theta = NULL
for (i in 1:nsim) {
prop_theta = curr_theta + runif(1, -.25, +.25)
prop_logf  = logf1(prop_theta) + logf2(prop_theta)
logu       = log(runif(1))
accept = (logu < prop_logf - curr_logf)
if (accept) {
theta = c(theta, prop_theta)
curr_theta = prop_theta
curr_logf  = prop_logf
} else {
theta = c(theta, curr_theta)
}
}
plot(ts(theta))
plot(density(theta))
curve( dnorm(x,mu_pred, sd_pred), add=TRUE, col='blue')
mu_pred
sd_[sd_pred]
sd_pred
sigma
mu  = c(0,1)
tau = c(1,4)
sigma = tau^(-1/2)
mu_pred = weighted.mean(mu, w=tau)
sd_pred = 1/sqrt(sum(tau))
logf1 = function(theta) { dnorm(theta, mu[1], sigma[1], log=TRUE)}
logf2 = function(theta) { dnorm(theta, mu[2], sigma[2], log=TRUE)}
nsim = 100000
curr_theta = 0
curr_logf  = logf1(curr_theta) + logf2(curr_theta)
theta = NULL
for (i in 1:nsim) {
prop_theta = curr_theta + runif(1, -.25, +.25)
prop_logf  = logf1(prop_theta) + logf2(prop_theta)
logu       = log(runif(1))
accept = (logu < prop_logf - curr_logf)
if (accept) {
theta = c(theta, prop_theta)
curr_theta = prop_theta
curr_logf  = prop_logf
} else {
theta = c(theta, curr_theta)
}
}
plot(ts(theta))
plot(density(theta))
curve( dnorm(x,mu_pred, sd_pred), add=TRUE, col='blue')
mu_pred
sd_pred
sd_pred^2
QS = function(x, R=.20,alpha=15,P=28,H=34) {
w = min(.75, .25+.025*(P-alpha))
beta = max (  min(50, 4*H-3*P) , (4*H-P)/3 )
D = P-20          # delay index
C = (P+50)/2 - H  # control index
knot    = vector("numeric",5)
knot[1] = alpha
knot[2] = alpha + w*(P-alpha)
knot[3] = P
knot[4] = (P+H)/2
knot[5] = (H+beta)/2
A      = matrix(NA,5,5)
target = vector("numeric",5)
# target value at P=1
A[1,]     = (pmax(P-knot, 0))^2
target[1] = 1
# target value at H=1/2
A[2,]     = (pmax(H-knot, 0))^2
target[2] = 1/2
# target value at beta=0
A[3,]     = (pmax(beta-knot, 0))^2
target[3] = 0
# target slope at P=0
A[4,]     = 2*pmax(P-knot, 0)
target[4] = 0
# target slope at beta=0
A[5,]     = 2*pmax(beta-knot, 0)
target[5] = 0
# calculate thetas
theta = solve(A,target)
tmp = (pmax( outer(x,knot,"-") , 0))^2
y = (x >= alpha) * (x <= beta) * R * (tmp %*% theta)  # ASFRs
return(list(R=R,alpha=alpha,P=P,H=H,
theta=theta,knot=knot,w=w,beta=beta,delay=D,control=C,
x=as.vector(x) ,y=as.vector(y) ))
} #QS
x = seq(12,50,.10)
QS(x)
QS = function(x, R=.20,alpha=15,P=28,H=34) {
w = min(.75, .25+.025*(P-alpha))
beta = max (  min(50, 4*H-3*P) , (4*H-P)/3 )
D = P-20          # delay index
C = (P+50)/2 - H  # control index
knot    = vector("numeric",5)
knot[1] = alpha
knot[2] = alpha + w*(P-alpha)
knot[3] = P
knot[4] = (P+H)/2
knot[5] = (H+beta)/2
A      = matrix(NA,5,5)
target = vector("numeric",5)
# target value at P=1
A[1,]     = (pmax(P-knot, 0))^2
target[1] = 1
# target value at H=1/2
A[2,]     = (pmax(H-knot, 0))^2
target[2] = 1/2
# target value at beta=0
A[3,]     = (pmax(beta-knot, 0))^2
target[3] = 0
# target slope at P=0
A[4,]     = 2*pmax(P-knot, 0)
target[4] = 0
# target slope at beta=0
A[5,]     = 2*pmax(beta-knot, 0)
target[5] = 0
# calculate thetas
theta = solve(A,target)
tmp = (pmax( outer(x,knot,"-") , 0))^2
y = (x >= alpha) * (x <= beta) * R * (tmp %*% theta)  # ASFRs
return(list(R=R,alpha=alpha,P=P,H=H,
theta=theta,knot=knot,w=w,beta=beta,delay=D,control=C,
x=as.vector(x) ,y=as.vector(y) ))
} #QS
x = seq(12,50,.10)
z = QS(x)
str(z)
QS = function(x, R=.20,alpha=15,P=28,H=34) {
w = min(.75, .25+.025*(P-alpha))
beta = max (  min(50, 4*H-3*P) , (4*H-P)/3 )
D = P-20          # delay index
C = (P+50)/2 - H  # control index
knot    = vector("numeric",5)
knot[1] = alpha
knot[2] = alpha + w*(P-alpha)
knot[3] = P
knot[4] = (P+H)/2
knot[5] = (H+beta)/2
A      = matrix(NA,5,5)
target = vector("numeric",5)
# target value at P=1
A[1,]     = (pmax(P-knot, 0))^2
target[1] = 1
# target value at H=1/2
A[2,]     = (pmax(H-knot, 0))^2
target[2] = 1/2
# target value at beta=0
A[3,]     = (pmax(beta-knot, 0))^2
target[3] = 0
# target slope at P=0
A[4,]     = 2*pmax(P-knot, 0)
target[4] = 0
# target slope at beta=0
A[5,]     = 2*pmax(beta-knot, 0)
target[5] = 0
# calculate thetas
theta = solve(A,target)
tmp = (pmax( outer(x,knot,"-") , 0))^2
y = (x >= alpha) * (x <= beta) * R * (tmp %*% theta)  # ASFRs
return(list(R=R,alpha=alpha,P=P,H=H,
theta=theta,knot=knot,w=w,beta=beta,delay=D,control=C,
x=as.vector(x) ,y=as.vector(y) ))
} #QS
x = seq(12,50,.10)
z = QS(x)
plot(z)
graphics.off()
windows(record=TRUE)
QS = function(x, R=.20,alpha=15,P=28,H=34) {
w = min(.75, .25+.025*(P-alpha))
beta = max (  min(50, 4*H-3*P) , (4*H-P)/3 )
D = P-20          # delay index
C = (P+50)/2 - H  # control index
knot    = vector("numeric",5)
knot[1] = alpha
knot[2] = alpha + w*(P-alpha)
knot[3] = P
knot[4] = (P+H)/2
knot[5] = (H+beta)/2
A      = matrix(NA,5,5)
target = vector("numeric",5)
# target value at P=1
A[1,]     = (pmax(P-knot, 0))^2
target[1] = 1
# target value at H=1/2
A[2,]     = (pmax(H-knot, 0))^2
target[2] = 1/2
# target value at beta=0
A[3,]     = (pmax(beta-knot, 0))^2
target[3] = 0
# target slope at P=0
A[4,]     = 2*pmax(P-knot, 0)
target[4] = 0
# target slope at beta=0
A[5,]     = 2*pmax(beta-knot, 0)
target[5] = 0
# calculate thetas
theta = solve(A,target)
tmp = (pmax( outer(x,knot,"-") , 0))^2
y = (x >= alpha) * (x <= beta) * R * (tmp %*% theta)  # ASFRs
return(list(R=R,alpha=alpha,P=P,H=H,
theta=theta,knot=knot,w=w,beta=beta,delay=D,control=C,
x=as.vector(x) ,y=as.vector(y) ))
} #QS
x = seq(12,50,.10)
z = QS(x)
plot(z)
graphics.off()
windows(record=TRUE)
QS = function(x, R=.20,alpha=15,P=28,H=34) {
w = min(.75, .25+.025*(P-alpha))
beta = max (  min(50, 4*H-3*P) , (4*H-P)/3 )
D = P-20          # delay index
C = (P+50)/2 - H  # control index
knot    = vector("numeric",5)
knot[1] = alpha
knot[2] = alpha + w*(P-alpha)
knot[3] = P
knot[4] = (P+H)/2
knot[5] = (H+beta)/2
A      = matrix(NA,5,5)
target = vector("numeric",5)
# target value at P=1
A[1,]     = (pmax(P-knot, 0))^2
target[1] = 1
# target value at H=1/2
A[2,]     = (pmax(H-knot, 0))^2
target[2] = 1/2
# target value at beta=0
A[3,]     = (pmax(beta-knot, 0))^2
target[3] = 0
# target slope at P=0
A[4,]     = 2*pmax(P-knot, 0)
target[4] = 0
# target slope at beta=0
A[5,]     = 2*pmax(beta-knot, 0)
target[5] = 0
# calculate thetas
theta = solve(A,target)
tmp = (pmax( outer(x,knot,"-") , 0))^2
y = (x >= alpha) * (x <= beta) * R * (tmp %*% theta)  # ASFRs
return(list(R=R,alpha=alpha,P=P,H=H,
theta=theta,knot=knot,w=w,beta=beta,delay=D,control=C,
x=as.vector(x) ,y=as.vector(y) ))
} #QS
x = seq(12,50,.10)
z = QS(x)
plot(z, type='l')
graphics.off()
windows(record=TRUE)
QS = function(x, R=.20,alpha=15,P=28,H=34) {
w = min(.75, .25+.025*(P-alpha))
beta = max (  min(50, 4*H-3*P) , (4*H-P)/3 )
D = P-20          # delay index
C = (P+50)/2 - H  # control index
knot    = vector("numeric",5)
knot[1] = alpha
knot[2] = alpha + w*(P-alpha)
knot[3] = P
knot[4] = (P+H)/2
knot[5] = (H+beta)/2
A      = matrix(NA,5,5)
target = vector("numeric",5)
# target value at P=1
A[1,]     = (pmax(P-knot, 0))^2
target[1] = 1
# target value at H=1/2
A[2,]     = (pmax(H-knot, 0))^2
target[2] = 1/2
# target value at beta=0
A[3,]     = (pmax(beta-knot, 0))^2
target[3] = 0
# target slope at P=0
A[4,]     = 2*pmax(P-knot, 0)
target[4] = 0
# target slope at beta=0
A[5,]     = 2*pmax(beta-knot, 0)
target[5] = 0
# calculate thetas
theta = solve(A,target)
tmp = (pmax( outer(x,knot,"-") , 0))^2
y = (x >= alpha) * (x <= beta) * R * (tmp %*% theta)  # ASFRs
return(list(R=R,alpha=alpha,P=P,H=H,
theta=theta,knot=knot,w=w,beta=beta,delay=D,control=C,
x=as.vector(x) ,y=as.vector(y) ))
} #QS
x = seq(12,50,.10)
z = QS(x)
plot(z, type='l', ylab='f(a)', xlab='a')
plot(z, type='l', ylab='f(a)', xlab='a', bty='l')
plot(z, type='l', ylab='f(a)', xlab='a', bty='l')
abline(h=0, color='lightgrey')
plot(z, type='l', ylab='f(a)', xlab='a', bty='l', lwd=4, axes=FALSE)
axis(1,pos=0)
plot(z, type='l', ylab='f(a)', xlab='a', bty='l', lwd=4, axes=FALSE)
axis(1,pos=0, at=seq(15,50,5))
plot(z, type='l', ylab='f', xlab='age', bty='l', lwd=4, axes=FALSE)
axis(1,pos=0, at=seq(15,50,5))
plot(z, type='l', ylab='rate', xlab='age', bty='l', lwd=4, axes=FALSE)
axis(1,pos=0, at=seq(15,50,5))
plot(z, type='l', ylab='rate', xlab='age', bty='l', lwd=4, axes=FALSE)
axis(1,pos=0, at=seq(15,50,5))
axis(2)
graphics.off()
windows(record=TRUE)
QS = function(x, R=.20,alpha=15,P=28,H=34) {
w = min(.75, .25+.025*(P-alpha))
beta = max (  min(50, 4*H-3*P) , (4*H-P)/3 )
D = P-20          # delay index
C = (P+50)/2 - H  # control index
knot    = vector("numeric",5)
knot[1] = alpha
knot[2] = alpha + w*(P-alpha)
knot[3] = P
knot[4] = (P+H)/2
knot[5] = (H+beta)/2
A      = matrix(NA,5,5)
target = vector("numeric",5)
# target value at P=1
A[1,]     = (pmax(P-knot, 0))^2
target[1] = 1
# target value at H=1/2
A[2,]     = (pmax(H-knot, 0))^2
target[2] = 1/2
# target value at beta=0
A[3,]     = (pmax(beta-knot, 0))^2
target[3] = 0
# target slope at P=0
A[4,]     = 2*pmax(P-knot, 0)
target[4] = 0
# target slope at beta=0
A[5,]     = 2*pmax(beta-knot, 0)
target[5] = 0
# calculate thetas
theta = solve(A,target)
tmp = (pmax( outer(x,knot,"-") , 0))^2
y = (x >= alpha) * (x <= beta) * R * (tmp %*% theta)  # ASFRs
return(list(R=R,alpha=alpha,P=P,H=H,
theta=theta,knot=knot,w=w,beta=beta,delay=D,control=C,
x=as.vector(x) ,y=as.vector(y) ))
} #QS
x = seq(12,50,.10)
z = QS(x)
plot(z, type='l', ylab='rate', xlab='age', bty='l', lwd=4, axes=FALSE)
axis(1,pos=0, at=seq(15,50,5))
axis(2)
library(tidyverse)
library(scales)
# abbreviations
tmp = data.frame( name=state.name, abb = state.abb)
tmp = rbind(tmp,  data.frame(name=c('Puerto Rico','District of Columbia'), abb=c('PR','DC')))
D = read.csv('nst-est2018-popchg2010_2018.csv', as.is=TRUE) %>%
filter(SUMLEV==40)
setwd("~/GitHub/bonecave/2010-2018 pop change US states")
library(tidyverse)
library(scales)
# abbreviations
tmp = data.frame( name=state.name, abb = state.abb)
tmp = rbind(tmp,  data.frame(name=c('Puerto Rico','District of Columbia'), abb=c('PR','DC')))
D = read.csv('nst-est2018-popchg2010_2018.csv', as.is=TRUE) %>%
filter(SUMLEV==40)
head(D)
D = read.csv('nst-est2018-popchg2010_2018.csv', as.is=TRUE) %>%
filter(SUMLEV==40) %>%
select(name    = NAME,
contains('POPESTIMATE'))
names(D)
head(D)
D = read.csv('nst-est2018-popchg2010_2018.csv', as.is=TRUE) %>%
filter(SUMLEV==40,
NAME %in% c('Florida','Puerto Rico')) %>%
select(name    = NAME,
contains('POPESTIMATE'))
D
D = read.csv('nst-est2018-popchg2010_2018.csv', as.is=TRUE) %>%
filter(SUMLEV==40,
NAME %in% c('Florida','Puerto Rico')) %>%
select(name    = NAME,
contains('POPESTIMATE')) %>%
left_join( tmp)
# abbreviations
tmp = data.frame( name=state.name, abb = state.abb)
tmp = rbind(tmp,  data.frame(name=c('Puerto Rico','District of Columbia'), abb=c('PR','DC')))
D = read.csv('nst-est2018-popchg2010_2018.csv', as.is=TRUE) %>%
filter(SUMLEV==40,
NAME %in% c('Florida','Puerto Rico')) %>%
select(name    = NAME,
contains('POPESTIMATE')) %>%
left_join( tmp)
D
plot(2010:2018, D[2,2:10])
windows()
plot(2010:2018, D[2,2:10])
plot(2010:2017, diff(D[2,2:10]))
plot(2010:2017, diff(D[2,2:10]))
D[2,2:10]
as.vector(D[2,2:10])
diff(as.vector(D[2,2:10]))
D[2,2:10] %>% class()
as.numeric(D[2,2:10]) %>% class()
diff(as.numeric(D[2,2:10]))
plot(2010:2017,diff(as.numeric(D[2,2:10]))
)
plot(2010:2017,diff(as.numeric(D[2,2:10])), type='h')
plot(2010:2017,diff(as.numeric(D[1,2:10])), type='h')
plot(2010:2017,diff(as.numeric(D[2,2:10]))
plot(2010:2017,diff(as.numeric(D[1,2:10])), type='h')
plot(2010:2017,diff(as.numeric(D[2,2:10])), type='h')
plot(2010:2017,diff(as.numeric(D[2,2:10])), type='h', ylim=c(0,-130000))
plot(2010:2017,diff(as.numeric(D[2,2:10])), type='h', ylim=c(-130000,0))
